// P2P - komunikacja bezpo≈õrednia miƒôdzy kontrolerem a grƒÖ u≈ºywajƒÖc PeerJS
class PeerToPeerConnection {
    constructor() {
        this.isHost = false;
        this.isController = false;
        this.playerId = null;
        this.peer = null;
        this.connections = new Map(); // Map playerId -> connection
        this.connected = false;
        this.hostPeerId = null;
        this.connectionToHost = null;

        console.log('üî∞ PeerToPeerConnection z PeerJS zainicjalizowany');

        // Sprawd≈∫ czy PeerJS jest dostƒôpne
        if (typeof Peer === 'undefined') {
            console.error('‚ùå PeerJS nie jest za≈Çadowane!');
            return;
        }
    }

    // Inicjalizacja jako host (gra)
    async initAsHost() {
        console.log('üñ•Ô∏è Inicjalizacja P2P jako host');
        this.isHost = true;

        try {
            // Utw√≥rz peer z unikalnym ID
            this.peer = new Peer(`pong-host-${Date.now()}`, {
                debug: 2,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });

            this.peer.on('open', (id) => {
                console.log('‚úÖ Host peer ID:', id);
                this.hostPeerId = id;
                this.displayPeerID(id);
            });

            this.peer.on('connection', (conn) => {
                console.log('üì• Nowe po≈ÇƒÖczenie od:', conn.peer);
                this.handleIncomingConnection(conn);
            });

            this.peer.on('error', (err) => {
                console.error('‚ùå B≈ÇƒÖd peer:', err);
            });

        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd inicjalizacji hosta:', error);
        }
    }

    // Inicjalizacja jako kontroler
    async initAsController(playerId, hostPeerId) {
        console.log(`üì± Inicjalizacja P2P jako kontroler dla gracza ${playerId}`);
        this.isController = true;
        this.playerId = playerId;
        this.hostPeerId = hostPeerId;

        try {
            // Utw√≥rz peer dla kontrolera
            this.peer = new Peer(`controller-${playerId}-${Date.now()}`, {
                debug: 2,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });

            this.peer.on('open', (id) => {
                console.log('‚úÖ Kontroler peer ID:', id);
                this.connectToHost();
            });

            this.peer.on('error', (err) => {
                console.error('‚ùå B≈ÇƒÖd peer kontrolera:', err);
            });

        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd inicjalizacji kontrolera:', error);
        }
    }

    // Po≈ÇƒÖcz siƒô z hostem
    connectToHost() {
        if (!this.hostPeerId) {
            console.error('‚ùå Brak ID hosta');
            return;
        }

        console.log(`üîó ≈ÅƒÖczenie z hostem: ${this.hostPeerId}`);

        this.connectionToHost = this.peer.connect(this.hostPeerId, {
            metadata: { playerId: this.playerId }
        });

        this.connectionToHost.on('open', () => {
            console.log('‚úÖ Po≈ÇƒÖczono z hostem');
            this.connected = true;
            this.onConnectionOpen();
        });

        this.connectionToHost.on('data', (data) => {
            this.handleDataFromHost(data);
        });

        this.connectionToHost.on('close', () => {
            console.log('üîå Po≈ÇƒÖczenie z hostem zamkniƒôte');
            this.connected = false;
            this.onConnectionClose();
        });

        this.connectionToHost.on('error', (err) => {
            console.error('‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z hostem:', err);
        });
    }

    // Obs≈Çuga przychodzƒÖcego po≈ÇƒÖczenia (host)
    handleIncomingConnection(conn) {
        const playerId = conn.metadata?.playerId;

        if (!playerId) {
            console.error('‚ùå Brak playerId w metadanych');
            conn.close();
            return;
        }

        console.log(`üì• Akceptujƒô po≈ÇƒÖczenie od gracza: ${playerId}`);
        this.connections.set(playerId, conn);

        conn.on('open', () => {
            console.log(`‚úÖ Po≈ÇƒÖczenie z graczem ${playerId} otwarte`);
            this.onPlayerConnected(playerId);
        });

        conn.on('data', (data) => {
            this.handleDataFromPlayer(playerId, data);
        });

        conn.on('close', () => {
            console.log(`üîå Gracz ${playerId} roz≈ÇƒÖczony`);
            this.connections.delete(playerId);
            this.onPlayerDisconnected(playerId);
        });

        conn.on('error', (err) => {
            console.error(`‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z graczem ${playerId}:`, err);
        });
    }

    // Wy≈õlij dane do hosta (kontroler)
    sendToHost(data) {
        if (this.connectionToHost && this.connected) {
            this.connectionToHost.send(data);
        } else {
            console.warn('‚ö†Ô∏è Brak po≈ÇƒÖczenia z hostem');
        }
    }

    // Wy≈õlij dane do gracza (host)
    sendToPlayer(playerId, data) {
        const conn = this.connections.get(playerId);
        if (conn) {
            conn.send(data);
        } else {
            console.warn(`‚ö†Ô∏è Brak po≈ÇƒÖczenia z graczem ${playerId}`);
        }
    }

    // Wy≈õlij dane do wszystkich graczy (host)
    broadcast(data) {
        this.connections.forEach((conn, playerId) => {
            conn.send(data);
        });
    }

    // Obs≈Çuga danych od gracza (host)
    handleDataFromPlayer(playerId, data) {
        console.log(`üì• Dane od gracza ${playerId}:`, data);

        // Przeka≈º dane do communication.js
        if (window.gameComm && typeof window.gameComm.handlePlayerData === 'function') {
            // Konwertuj dane do formatu oczekiwanego przez handlePlayerData
            if (data.type === 'playerData') {
                // Konwertuj playerId z "player2" na "2"
                const playerNumber = data.playerId.replace('player', '');

                window.gameComm.handlePlayerData({
                    playerId: playerNumber, // "2" zamiast "player2"
                    tilt: data.tilt,
                    orientation: data.orientation,
                    timestamp: data.timestamp
                });
            }
        }

        // Przeka≈º tak≈ºe do gry je≈õli istnieje
        if (window.game) {
            const playerNumber = data.playerId.replace('player', '');
            if (playerNumber === '1') {
                window.game.player1Tilt = data.tilt;
            } else if (playerNumber === '2') {
                window.game.player2Tilt = data.tilt;
            }
        }
    }

    // Obs≈Çuga danych od hosta (kontroler)
    handleDataFromHost(data) {
        console.log('ÔøΩÔøΩ Dane od hosta:', data);
        // Tu mo≈ºna dodaƒá obs≈Çugƒô danych od hosta je≈õli potrzebne
    }

    // Callback gdy gracz siƒô po≈ÇƒÖczy≈Ç
    onPlayerConnected(playerId) {
        console.log(`üéÆ Gracz ${playerId} po≈ÇƒÖczony przez P2P`);

        // Wywo≈Çaj handlePlayerConnect z communication.js
        if (window.gameComm && typeof window.gameComm.handlePlayerConnect === 'function') {
            window.gameComm.handlePlayerConnect(playerId);
        }
    }

    // Callback gdy gracz siƒô roz≈ÇƒÖczy≈Ç
    onPlayerDisconnected(playerId) {
        console.log(`‚ùå Gracz ${playerId} roz≈ÇƒÖczony`);

        // Wywo≈Çaj odpowiedniƒÖ funkcjƒô z communication.js je≈õli istnieje
        if (window.gameComm && typeof window.gameComm.handlePlayerDisconnect === 'function') {
            window.gameComm.handlePlayerDisconnect(playerId);
        }
    }

    // Callback gdy po≈ÇƒÖczenie siƒô otwiera (kontroler)
    onConnectionOpen() {
        console.log('üéÆ Kontroler po≈ÇƒÖczony przez P2P');

        // Aktualizuj interfejs kontrolera - sprawd≈∫ oba mo≈ºliwe obiekty
        if (window.gameComm) {
            window.gameComm.p2pConnected = true;
            window.gameComm.updateConnectionStatus();
        }

        if (window.gameCommunication) {
            window.gameCommunication.p2pConnected = true;
            window.gameCommunication.updateConnectionStatus();
        }
    }

    // Callback gdy po≈ÇƒÖczenie siƒô zamyka (kontroler)
    onConnectionClose() {
        console.log('‚ùå Kontroler roz≈ÇƒÖczony');

        // Aktualizuj interfejs kontrolera - sprawd≈∫ oba mo≈ºliwe obiekty
        if (window.gameComm) {
            window.gameComm.p2pConnected = false;
            window.gameComm.updateConnectionStatus();
        }

        if (window.gameCommunication) {
            window.gameCommunication.p2pConnected = false;
            window.gameCommunication.updateConnectionStatus();
        }
    }

    // Wy≈õwietl ID hosta na ekranie
    displayPeerID(peerId) {
        // Zaktualizuj QR kody z nowym ID
        this.updateQRCodes(peerId);

        // Wy≈õwietl ID na ekranie
        const peerIdDisplay = document.getElementById('peerIdDisplay');
        if (peerIdDisplay) {
            peerIdDisplay.textContent = `Peer ID: ${peerId}`;
        }
    }

    // Zaktualizuj QR kody z Peer ID
    updateQRCodes(peerId) {
        // Automatycznie wykryj bazowy URL z aktualnej ≈õcie≈ºki (dla GitHub Pages)
        let currentPath = window.location.pathname;

        // Je≈õli ≈õcie≈ºka to `/pong` (bez slash na ko≈Ñcu), dodaj slash
        if (currentPath === '/pong') {
            currentPath = '/pong/';
        }

        // Je≈õli ≈õcie≈ºka to `/` (root), zostaw jak jest
        // Je≈õli ≈õcie≈ºka to `/pong/` lub inna ze slash, zostaw jak jest
        const basePath = currentPath.endsWith('/') ? currentPath : currentPath + '/';

        console.log('üîç p2p.js - Wykryta ≈õcie≈ºka:', {
            originalPath: window.location.pathname,
            processedPath: currentPath,
            basePath: basePath
        });

        const baseUrl = `${window.location.protocol}//${window.location.host}${basePath}controller.html`;

        // QR kod dla gracza 1
        const player1Url = `${baseUrl}?player=player1&peerID=${peerId}`;
        console.log('üîó p2p.js - Player 1 URL:', player1Url);

        const qr1 = document.getElementById('qr1');
        if (qr1 && window.QRCode) {
            qr1.innerHTML = '';
            new QRCode(qr1, {
                text: player1Url,
                width: 200,
                height: 200
            });
        }

        // QR kod dla gracza 2
        const player2Url = `${baseUrl}?player=player2&peerID=${peerId}`;
        console.log('üîó p2p.js - Player 2 URL:', player2Url);

        const qr2 = document.getElementById('qr2');
        if (qr2 && window.QRCode) {
            qr2.innerHTML = '';
            new QRCode(qr2, {
                text: player2Url,
                width: 200,
                height: 200
            });
        }
    }

    // Zamknij wszystkie po≈ÇƒÖczenia
    disconnect() {
        console.log('üîå Zamykanie po≈ÇƒÖcze≈Ñ P2P');

        if (this.connectionToHost) {
            this.connectionToHost.close();
            this.connectionToHost = null;
        }

        this.connections.forEach((conn) => {
            conn.close();
        });
        this.connections.clear();

        if (this.peer) {
            this.peer.destroy();
            this.peer = null;
        }

        this.connected = false;
    }

    // Sprawd≈∫ czy gracz jest po≈ÇƒÖczony
    isPlayerConnected(playerId) {
        return this.connections.has(playerId);
    }

    // Pobierz liczbƒô po≈ÇƒÖczonych graczy
    getConnectedPlayersCount() {
        return this.connections.size;
    }
}

// Globalna instancja P2P
window.p2pConnection = new PeerToPeerConnection();
